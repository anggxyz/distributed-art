"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const normalize_address_1 = require("@0xcert/ethereum-utils/dist/lib/normalize-address");
const scaffold_1 = require("@0xcert/scaffold");
const events_1 = require("events");
var MutationStatus;
(function (MutationStatus) {
    MutationStatus[MutationStatus["INITIALIZED"] = 0] = "INITIALIZED";
    MutationStatus[MutationStatus["PENDING"] = 1] = "PENDING";
    MutationStatus[MutationStatus["COMPLETED"] = 2] = "COMPLETED";
})(MutationStatus = exports.MutationStatus || (exports.MutationStatus = {}));
class Mutation extends events_1.EventEmitter {
    constructor(provider, id) {
        super();
        this._confirmations = 0;
        this._speed = 14000;
        this._status = MutationStatus.INITIALIZED;
        this._id = id;
        this._provider = provider;
        if (this._provider.sandbox) {
            this._status = MutationStatus.COMPLETED;
        }
    }
    get id() {
        return this._id;
    }
    get provider() {
        return this._provider;
    }
    get confirmations() {
        return this._confirmations;
    }
    get senderId() {
        return this._senderId;
    }
    get receiverId() {
        return this._receiverId;
    }
    isPending() {
        return this._status === MutationStatus.PENDING;
    }
    isCompleted() {
        return this._status === MutationStatus.COMPLETED;
    }
    emit(...args) {
        super.emit.call(this, ...args);
        return this;
    }
    on(...args) {
        super.on.call(this, ...args);
        return this;
    }
    once(...args) {
        super.once.call(this, ...args);
        return this;
    }
    off(event, handler) {
        if (handler) {
            super.off(event, handler);
        }
        else {
            super.removeAllListeners(event);
        }
        return this;
    }
    complete() {
        return __awaiter(this, void 0, void 0, function* () {
            const start = this._status === MutationStatus.INITIALIZED;
            if (this.isCompleted()) {
                return this;
            }
            else if (!this.isPending()) {
                this._status = MutationStatus.PENDING;
                this._started = Date.now();
            }
            yield new Promise((resolve, reject) => {
                if (!this.isCompleted()) {
                    this.once(scaffold_1.MutationEvent.COMPLETE, () => resolve());
                    this.once(scaffold_1.MutationEvent.ERROR, (err) => reject(err));
                }
                else {
                    resolve();
                }
                if (start) {
                    this.loopUntilResolved();
                }
            });
            return this;
        });
    }
    forget() {
        if (this._timer) {
            clearTimeout(this._timer);
            this._timer = undefined;
        }
        return this;
    }
    loopUntilResolved() {
        return __awaiter(this, void 0, void 0, function* () {
            const tx = yield this.getTransactionObject();
            if (tx && (!tx.to || tx.to === '0x0')) {
                tx.to = yield this.getTransactionReceipt().then((r) => r ? r.contractAddress : null);
            }
            if (tx && tx.to) {
                this._senderId = normalize_address_1.normalizeAddress(tx.from);
                this._receiverId = normalize_address_1.normalizeAddress(tx.to);
                this._confirmations = yield this.getLastBlock()
                    .then((lastBlock) => lastBlock - parseInt(tx.blockNumber || lastBlock))
                    .then((num) => num < 0 ? 0 : num);
                if (this._confirmations >= this._provider.requiredConfirmations) {
                    this._status = MutationStatus.COMPLETED;
                    return this.emit(scaffold_1.MutationEvent.COMPLETE, this);
                }
                else {
                    this.emit(scaffold_1.MutationEvent.CONFIRM, this);
                }
            }
            if (this._provider.mutationTimeout === -1 || Date.now() - this._started < this._provider.mutationTimeout) {
                this._timer = setTimeout(this.loopUntilResolved.bind(this), this._speed);
            }
            else {
                this.emit(scaffold_1.MutationEvent.ERROR, new Error('Mutation has timed out'));
            }
        });
    }
    getTransactionObject() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this._provider.post({
                method: 'eth_getTransactionByHash',
                params: [this.id],
            });
            return res.result;
        });
    }
    getTransactionReceipt() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this._provider.post({
                method: 'eth_getTransactionReceipt',
                params: [this.id],
            });
            return res.result;
        });
    }
    getLastBlock() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this._provider.post({
                method: 'eth_blockNumber',
            });
            return parseInt(res.result);
        });
    }
}
exports.Mutation = Mutation;
//# sourceMappingURL=mutation.js.map
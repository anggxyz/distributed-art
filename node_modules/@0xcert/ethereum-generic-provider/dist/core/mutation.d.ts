/// <reference types="node" />
import { MutationBase, MutationEvent } from '@0xcert/scaffold';
import { EventEmitter } from 'events';
export declare enum MutationStatus {
    INITIALIZED = 0,
    PENDING = 1,
    COMPLETED = 2
}
export declare class Mutation extends EventEmitter implements MutationBase {
    protected _id: string;
    protected _confirmations: number;
    protected _senderId: string;
    protected _receiverId: string;
    protected _provider: any;
    protected _speed: number;
    protected _timer: any;
    protected _started: number;
    protected _status: MutationStatus;
    constructor(provider: any, id: string);
    readonly id: string;
    readonly provider: any;
    readonly confirmations: number;
    readonly senderId: string;
    readonly receiverId: string;
    isPending(): boolean;
    isCompleted(): boolean;
    emit(event: MutationEvent.CONFIRM, mutation: Mutation): any;
    emit(event: MutationEvent.COMPLETE, mutation: Mutation): any;
    emit(event: MutationEvent.ERROR, error: any): any;
    on(event: MutationEvent.CONFIRM, handler: (m: Mutation) => any): any;
    on(event: MutationEvent.COMPLETE, handler: (m: Mutation) => any): any;
    on(event: MutationEvent.ERROR, handler: (e: any, m: Mutation) => any): any;
    once(event: MutationEvent.CONFIRM, handler: (m: Mutation) => any): any;
    once(event: MutationEvent.COMPLETE, handler: (m: Mutation) => any): any;
    once(event: MutationEvent.ERROR, handler: (e: any, m: Mutation) => any): any;
    off(event: MutationEvent.ERROR, handler: (e: any, m: Mutation) => any): any;
    off(event: MutationEvent): any;
    complete(): Promise<this>;
    forget(): this;
    protected loopUntilResolved(): Promise<any>;
    protected getTransactionObject(): Promise<any>;
    protected getTransactionReceipt(): Promise<any>;
    protected getLastBlock(): Promise<number>;
}
